From d5711bb3da43bff3f90a33c5d5ab9b5a262660c5 Mon Sep 17 00:00:00 2001
From: Pavel Odintsov <pavel.odintsov@gmail.com>
Date: Sun, 4 Feb 2018 13:10:57 +0000
Subject: [PATCH 1/2] Added support for Memory Model Aware Atomic Operations

---
 src/fastnetmon.cpp | 100 +++++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 97 insertions(+), 3 deletions(-)

diff --git a/src/fastnetmon.cpp b/src/fastnetmon.cpp
index f337e48..1d6153f 100644
--- a/src/fastnetmon.cpp
+++ b/src/fastnetmon.cpp
@@ -1671,18 +1671,31 @@ void ipv6_traffic_processor() {
 
         while ((count = multi_process_queue_for_ipv6_counters.try_dequeue_bulk(packets_from_queue, 32)) != 0) {
             for (std::size_t i = 0; i != count; ++i) {
+#ifdef USE_NEW_ATOMIC_BUILTINS
+                __atomic_add_fetch(&total_ipv6_packets, 1, __ATOMIC_RELAXED);
+#else
                 __sync_fetch_and_add(&total_ipv6_packets, 1);
-            
+#endif
+
                 direction packet_direction = packets_from_queue[i].packet_direction;
 
                 uint64_t sampled_number_of_packets = packets_from_queue[i].number_of_packets * packets_from_queue[i].sample_ratio;
                 uint64_t sampled_number_of_bytes = packets_from_queue[i].length * packets_from_queue[i].sample_ratio;
 
+#ifdef USE_NEW_ATOMIC_BUILTINS
+                __atomic_add_fetch(&total_counters[packet_direction].packets, sampled_number_of_packets, __ATOMIC_RELAXED);
+                __atomic_add_fetch(&total_counters[packet_direction].bytes,   sampled_number_of_bytes, __ATOMIC_RELAXED);
+#else
                 __sync_fetch_and_add(&total_counters[packet_direction].packets, sampled_number_of_packets);
                 __sync_fetch_and_add(&total_counters[packet_direction].bytes,   sampled_number_of_bytes);
+#endif
 
                 if (packet_direction != OTHER) {
+#ifdef USE_NEW_ATOMIC_BUILTINS
+                    __atomic_add_fetch(&our_ipv6_packets, 1, __ATOMIC_RELAXED);
+#else
                     __sync_fetch_and_add(&our_ipv6_packets, 1);
+#endif
                 }       
             }
         }
@@ -1705,7 +1718,14 @@ void process_packet(simple_packet& current_packet) {
         // TODO: move to bulk operations here!
         multi_process_queue_for_ipv6_counters.enqueue(current_packet);
 #else
+
+
+#ifdef USE_NEW_ATOMIC_BUILTINS
+        __atomic_add_fetch(&total_ipv6_packets, 1, __ATOMIC_RELAXED);
+#else       
         __sync_fetch_and_add(&total_ipv6_packets, 1);
+#endif
+
 #endif
 
         return;
@@ -1795,8 +1815,13 @@ void process_packet(simple_packet& current_packet) {
     uint64_t sampled_number_of_packets = current_packet.number_of_packets * current_packet.sample_ratio;
     uint64_t sampled_number_of_bytes = current_packet.length * current_packet.sample_ratio;
 
-    __sync_fetch_and_add(&total_counters[packet_direction].packets, sampled_number_of_packets);
+#ifdef USE_NEW_ATOMIC_BUILTINS
+    __atomic_add_fetch(&total_counters[packet_direction].packets, sampled_number_of_packets, __ATOMIC_RELAXED);
+    __atomic_add_fetch(&total_counters[packet_direction].bytes,   sampled_number_of_bytes, __ATOMIC_RELAXED);
+#else
+    __sync_fetch_and_add(&total_counters[packet_direction].packets, sampled_number_of_packets); 
     __sync_fetch_and_add(&total_counters[packet_direction].bytes,   sampled_number_of_bytes);
+#endif
 
     // Incerementi main and per protocol packet counters
     if (packet_direction == OUTGOING) {
@@ -1816,19 +1841,34 @@ void process_packet(simple_packet& current_packet) {
         map_element* current_element = &itr->second[shift_in_vector];
 
         // Main packet/bytes counter
+#ifdef USE_NEW_ATOMIC_BUILTINS
+        __atomic_add_fetch(&current_element->out_packets, sampled_number_of_packets, __ATOMIC_RELAXED);
+        __atomic_add_fetch(&current_element->out_bytes, sampled_number_of_bytes, __ATOMIC_RELAXED);
+#else
         __sync_fetch_and_add(&current_element->out_packets, sampled_number_of_packets);
         __sync_fetch_and_add(&current_element->out_bytes, sampled_number_of_bytes);
+#endif
 
         // Fragmented IP packets
         if (current_packet.ip_fragmented) {
+#ifdef USE_NEW_ATOMIC_BUILTINS
+            __atomic_add_fetch(&current_element->fragmented_out_packets, sampled_number_of_packets, __ATOMIC_RELAXED);
+            __atomic_add_fetch(&current_element->fragmented_out_bytes, sampled_number_of_bytes, __ATOMIC_RELAXED);
+#else
             __sync_fetch_and_add(&current_element->fragmented_out_packets, sampled_number_of_packets);
             __sync_fetch_and_add(&current_element->fragmented_out_bytes, sampled_number_of_bytes);
+#endif
         }
 
         // TODO: add another counters
         if (enable_subnet_counters) {
+#ifdef USE_NEW_ATOMIC_BUILTINS
+            __atomic_add_fetch(&subnet_counter->out_packets, sampled_number_of_packets, __ATOMIC_RELAXED);
+            __atomic_add_fetch(&subnet_counter->out_bytes,   sampled_number_of_bytes, __ATOMIC_RELAXED);
+#else
             __sync_fetch_and_add(&subnet_counter->out_packets, sampled_number_of_packets);
             __sync_fetch_and_add(&subnet_counter->out_bytes,   sampled_number_of_bytes);
+#endif
         }
 
         conntrack_main_struct* current_element_flow = NULL;
@@ -1867,12 +1907,22 @@ void process_packet(simple_packet& current_packet) {
         }
 
         if (current_packet.protocol == IPPROTO_TCP) {
+#ifdef USE_NEW_ATOMIC_BUILTINS
+            __atomic_add_fetch(&current_element->tcp_out_packets, sampled_number_of_packets, __ATOMIC_RELAXED);
+            __atomic_add_fetch(&current_element->tcp_out_bytes, sampled_number_of_bytes, __ATOMIC_RELAXED);
+#else
             __sync_fetch_and_add(&current_element->tcp_out_packets, sampled_number_of_packets);
             __sync_fetch_and_add(&current_element->tcp_out_bytes, sampled_number_of_bytes);
+#endif
 
             if (extract_bit_value(current_packet.flags, TCP_SYN_FLAG_SHIFT)) {
+#ifdef USE_NEW_ATOMIC_BUILTINS
+                __atomic_add_fetch(&current_element->tcp_syn_out_packets, sampled_number_of_packets, __ATOMIC_RELAXED);
+                __atomic_add_fetch(&current_element->tcp_syn_out_bytes, sampled_number_of_bytes, __ATOMIC_RELAXED);
+#else
                 __sync_fetch_and_add(&current_element->tcp_syn_out_packets, sampled_number_of_packets);
                 __sync_fetch_and_add(&current_element->tcp_syn_out_bytes, sampled_number_of_bytes);
+#endif
             }
 
             if (enable_conection_tracking) {
@@ -1886,8 +1936,13 @@ void process_packet(simple_packet& current_packet) {
                 flow_counter.unlock();
             }
         } else if (current_packet.protocol == IPPROTO_UDP) {
+#ifdef USE_NEW_ATOMIC_BUILTINS
+            __atomic_add_fetch(&current_element->udp_out_packets, sampled_number_of_packets, __ATOMIC_RELAXED);
+            __atomic_add_fetch(&current_element->udp_out_bytes, sampled_number_of_bytes, __ATOMIC_RELAXED);
+#else
             __sync_fetch_and_add(&current_element->udp_out_packets, sampled_number_of_packets);
             __sync_fetch_and_add(&current_element->udp_out_bytes, sampled_number_of_bytes);
+#endif
 
             if (enable_conection_tracking) {
                 flow_counter.lock();
@@ -1900,8 +1955,13 @@ void process_packet(simple_packet& current_packet) {
                 flow_counter.unlock();
             }
         } else if (current_packet.protocol == IPPROTO_ICMP) {
+#ifdef USE_NEW_ATOMIC_BUILTINS
+            __atomic_add_fetch(&current_element->icmp_out_packets, sampled_number_of_packets, __ATOMIC_RELAXED);
+            __atomic_add_fetch(&current_element->icmp_out_bytes, sampled_number_of_bytes, __ATOMIC_RELAXED);
+#else
             __sync_fetch_and_add(&current_element->icmp_out_packets, sampled_number_of_packets);
             __sync_fetch_and_add(&current_element->icmp_out_bytes, sampled_number_of_bytes);
+#endif
             // no flow tracking for icmp
         } else {
         }
@@ -1923,18 +1983,33 @@ void process_packet(simple_packet& current_packet) {
         map_element* current_element = &itr->second[shift_in_vector];
 
         // Main packet/bytes counter
+#ifdef USE_NEW_ATOMIC_BUILTINS
+        __atomic_add_fetch(&current_element->in_packets, sampled_number_of_packets, __ATOMIC_RELAXED);
+        __atomic_add_fetch(&current_element->in_bytes, sampled_number_of_bytes, __ATOMIC_RELAXED);
+#else
         __sync_fetch_and_add(&current_element->in_packets, sampled_number_of_packets);
         __sync_fetch_and_add(&current_element->in_bytes, sampled_number_of_bytes);
+#endif
 
         if (enable_subnet_counters) {
+#ifdef USE_NEW_ATOMIC_BUILTINS
+            __atomic_add_fetch(&subnet_counter->in_packets, sampled_number_of_packets, __ATOMIC_RELAXED);
+            __atomic_add_fetch(&subnet_counter->in_bytes,   sampled_number_of_bytes, __ATOMIC_RELAXED);
+#else
             __sync_fetch_and_add(&subnet_counter->in_packets, sampled_number_of_packets);
             __sync_fetch_and_add(&subnet_counter->in_bytes,   sampled_number_of_bytes);
+#endif
         }
 
         // Count fragmented IP packets
         if (current_packet.ip_fragmented) {
+#ifdef USE_NEW_ATOMIC_BUILTINS
+            __atomic_add_fetch(&current_element->fragmented_in_packets, sampled_number_of_packets, __ATOMIC_RELAXED);
+            __atomic_add_fetch(&current_element->fragmented_in_bytes, sampled_number_of_bytes, __ATOMIC_RELAXED);
+#else
             __sync_fetch_and_add(&current_element->fragmented_in_packets, sampled_number_of_packets);
             __sync_fetch_and_add(&current_element->fragmented_in_bytes, sampled_number_of_bytes);
+#endif
         }
 
         conntrack_main_struct* current_element_flow = NULL;
@@ -1973,12 +2048,22 @@ void process_packet(simple_packet& current_packet) {
         }
 
         if (current_packet.protocol == IPPROTO_TCP) {
+#ifdef USE_NEW_ATOMIC_BUILTINS
+            __atomic_add_fetch(&current_element->tcp_in_packets, sampled_number_of_packets, __ATOMIC_RELAXED);
+            __atomic_add_fetch(&current_element->tcp_in_bytes, sampled_number_of_bytes, __ATOMIC_RELAXED);
+#else
             __sync_fetch_and_add(&current_element->tcp_in_packets, sampled_number_of_packets);
             __sync_fetch_and_add(&current_element->tcp_in_bytes, sampled_number_of_bytes);
+#endif
 
             if (extract_bit_value(current_packet.flags, TCP_SYN_FLAG_SHIFT)) {
+#ifdef USE_NEW_ATOMIC_BUILTINS
+                __atomic_add_fetch(&current_element->tcp_syn_in_packets, sampled_number_of_packets, __ATOMIC_RELAXED);
+                __atomic_add_fetch(&current_element->tcp_syn_in_bytes, sampled_number_of_bytes, __ATOMIC_RELAXED);
+#else
                 __sync_fetch_and_add(&current_element->tcp_syn_in_packets, sampled_number_of_packets);
                 __sync_fetch_and_add(&current_element->tcp_syn_in_bytes, sampled_number_of_bytes);
+#endif
             }
 
             if (enable_conection_tracking) {
@@ -1992,8 +2077,13 @@ void process_packet(simple_packet& current_packet) {
                 flow_counter.unlock();
             }
         } else if (current_packet.protocol == IPPROTO_UDP) {
+#ifdef USE_NEW_ATOMIC_BUILTINS
+            __atomic_add_fetch(&current_element->udp_in_packets, sampled_number_of_packets, __ATOMIC_RELAXED);
+            __atomic_add_fetch(&current_element->udp_in_bytes, sampled_number_of_bytes, __ATOMIC_RELAXED);
+#else
             __sync_fetch_and_add(&current_element->udp_in_packets, sampled_number_of_packets);
             __sync_fetch_and_add(&current_element->udp_in_bytes, sampled_number_of_bytes);
+#endif
 
             if (enable_conection_tracking) {
                 flow_counter.lock();
@@ -2005,9 +2095,13 @@ void process_packet(simple_packet& current_packet) {
                 flow_counter.unlock();
             }
         } else if (current_packet.protocol == IPPROTO_ICMP) {
+#ifdef USE_NEW_ATOMIC_BUILTINS
+            __atomic_add_fetch(&current_element->icmp_in_packets, sampled_number_of_packets, __ATOMIC_RELAXED);
+            __atomic_add_fetch(&current_element->icmp_in_bytes, sampled_number_of_bytes, __ATOMIC_RELAXED);
+#else
             __sync_fetch_and_add(&current_element->icmp_in_packets, sampled_number_of_packets);
             __sync_fetch_and_add(&current_element->icmp_in_bytes, sampled_number_of_bytes);
-
+#endif
             // no flow tracking for icmp
         } else {
             // TBD
-- 
2.14.1

