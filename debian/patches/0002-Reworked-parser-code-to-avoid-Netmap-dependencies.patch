From 136b9c7c0fdd98ebc5ea88e837420234611713c7 Mon Sep 17 00:00:00 2001
From: Pavel Odintsov <pavel.odintsov@gmail.com>
Date: Thu, 27 Jul 2017 23:09:58 +0000
Subject: [PATCH 2/2] Reworked parser code to avoid Netmap dependencies

---
 src/CMakeLists.txt                               |  8 +++
 src/afpacket_plugin/afpacket_collector.cpp       | 13 +++--
 src/netmap_plugin/netmap_collector.cpp           | 68 ++---------------------
 src/pcap_reader.cpp                              |  5 +-
 src/snabbswitch_plugin/snabbswitch_collector.cpp |  7 ++-
 src/unified_parser.cpp                           | 69 ++++++++++++++++++++++++
 src/unified_parser.hpp                           |  7 +++
 7 files changed, 101 insertions(+), 76 deletions(-)
 create mode 100644 src/unified_parser.cpp
 create mode 100644 src/unified_parser.hpp

diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 4f56f3f..d87abc0 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -151,6 +151,10 @@ add_library(fastnetmon_pcap_format STATIC fastnetmon_pcap_format.cpp)
 # Our tools library
 add_library(fast_library STATIC fast_library.cpp)
 
+# Our parser
+add_library(unified_parser STATIC unified_parser.cpp)
+target_link_libraries(unified_parser fastnetmon_packet_parser)
+
 # Our ipfix database library
 add_library(ipfix_rfc STATIC ipfix_rfc.cpp)
 
@@ -190,6 +194,7 @@ endif()
 if (ENABLE_AFPACKET_SUPPORT)
    add_definitions(-DFASTNETMON_ENABLE_AFPACKET) 
    add_library(afpacket_plugin STATIC afpacket_plugin/afpacket_collector.cpp)
+   target_link_libraries(afpacket_plugin unified_parser)
 endif()
 
 # sFLOW plugin
@@ -512,6 +517,9 @@ target_link_libraries(fastnetmon ipfix_rfc)
 # Link to our functions
 target_link_libraries(fastnetmon fast_library)
 
+# link to our unified parser
+target_link_libraries(fastnetmon unified_parser)
+
 if (ENABLE_PFRING_SUPPORT)
     target_link_libraries(fastnetmon pfring_plugin)
     # Link hardware filter too
diff --git a/src/afpacket_plugin/afpacket_collector.cpp b/src/afpacket_plugin/afpacket_collector.cpp
index c5d7807..68e1036 100644
--- a/src/afpacket_plugin/afpacket_collector.cpp
+++ b/src/afpacket_plugin/afpacket_collector.cpp
@@ -43,6 +43,10 @@
 #include <linux/if_packet.h>
 #include <net/ethernet.h> /* the L2 protocols */
 
+#include "../unified_parser.hpp"
+
+bool afpacket_read_packet_length_from_ip_header = false;
+
 // Get log4cpp logger from main program
 extern log4cpp::Category& logger;
 
@@ -67,9 +71,6 @@ struct block_desc {
     struct tpacket_hdr_v1 h1;
 };
 
-// We will use this code from Global Symbols table (originally it's defined in netmap collector.cpp)
-bool parse_raw_packet_to_simple_packet(u_char* buffer, int len, simple_packet& packet);
-
 // Get interface number by name
 int get_interface_number_by_device_name(int socket_fd, std::string interface_name) {
     struct ifreq ifr;
@@ -116,7 +117,7 @@ void walk_block(struct block_desc *pbd, const int block_num) {
         u_char* data_pointer = (u_char*)((uint8_t *) ppd + ppd->tp_mac);
 
         simple_packet packet;
-        int parser_result = parse_raw_packet_to_simple_packet((u_char*)data_pointer, ppd->tp_snaplen, packet); 
+        int parser_result = parse_raw_packet_to_simple_packet((u_char*)data_pointer, ppd->tp_snaplen, packet, afpacket_read_packet_length_from_ip_header); 
 
         //char print_buffer[512];
         //fastnetmon_print_parsed_pkt(print_buffer, 512, data_pointer, &packet_header);
@@ -286,6 +287,10 @@ void start_afpacket_collection(process_packet_pointer func_ptr) {
     logger << log4cpp::Priority::INFO << "AF_PACKET plugin started";
     afpacket_process_func_ptr = func_ptr;
 
+    if (configuration_map.count("netmap_read_packet_length_from_ip_header") != 0) {
+        afpacket_read_packet_length_from_ip_header = configuration_map["netmap_read_packet_length_from_ip_header"] == "on";
+    }
+
     std::string interfaces_list = "";
 
     if (configuration_map.count("interfaces") != 0) {
diff --git a/src/netmap_plugin/netmap_collector.cpp b/src/netmap_plugin/netmap_collector.cpp
index bee681c..77e74f3 100644
--- a/src/netmap_plugin/netmap_collector.cpp
+++ b/src/netmap_plugin/netmap_collector.cpp
@@ -40,6 +40,8 @@ typedef cpuset_t cpu_set_t;
 
 #include "../fastnetmon_packet_parser.h"
 
+#include "../unified_parser.hpp"
+
 // For pooling operations
 #include <poll.h>
 
@@ -98,77 +100,13 @@ int receive_packets(struct netmap_ring* ring, int thread_number) {
     return (rx);
 }
 
-bool parse_raw_packet_to_simple_packet(u_char* buffer, int len, simple_packet& packet) {
-    struct pfring_pkthdr packet_header;
-
-    memset(&packet_header, 0, sizeof(packet_header));
-    packet_header.len = len;
-    packet_header.caplen = len;
-
-    // We do not calculate timestamps because timestamping is very CPU intensive operation:
-    // https://github.com/ntop/PF_RING/issues/9
-    u_int8_t timestamp = 0;
-    u_int8_t add_hash = 0;
-    fastnetmon_parse_pkt((u_char*)buffer, &packet_header, 4, timestamp, add_hash);
-
-    // char print_buffer[512];
-    // fastnetmon_print_parsed_pkt(print_buffer, 512, (u_char*)buffer, &packet_header);
-    // logger.info("%s", print_buffer);
-
-    if (packet_header.extended_hdr.parsed_pkt.ip_version != 4 && packet_header.extended_hdr.parsed_pkt.ip_version != 6) {
-        return false;
-    }
-
-    // We need this for deep packet inspection
-    packet.packet_payload_length = len;
-    packet.packet_payload_pointer = (void*)buffer;
-
-    packet.ip_protocol_version = packet_header.extended_hdr.parsed_pkt.ip_version;
-
-    if (packet.ip_protocol_version == 4) {
-        // IPv4
-
-        /* PF_RING stores data in host byte order but we use network byte order */
-        packet.src_ip = htonl(packet_header.extended_hdr.parsed_pkt.ip_src.v4);
-        packet.dst_ip = htonl(packet_header.extended_hdr.parsed_pkt.ip_dst.v4);
-    } else {
-        // IPv6
-        memcpy(packet.src_ipv6.s6_addr, packet_header.extended_hdr.parsed_pkt.ip_src.v6.s6_addr, 16);
-        memcpy(packet.dst_ipv6.s6_addr, packet_header.extended_hdr.parsed_pkt.ip_dst.v6.s6_addr, 16);
-    }
-
-    packet.source_port = packet_header.extended_hdr.parsed_pkt.l4_src_port;
-    packet.destination_port = packet_header.extended_hdr.parsed_pkt.l4_dst_port;
-
-    if (netmap_read_packet_length_from_ip_header) { 
-        packet.length = packet_header.extended_hdr.parsed_pkt.ip_total_size;
-    } else {
-        packet.length = packet_header.len;
-    }
-
-    packet.protocol = packet_header.extended_hdr.parsed_pkt.l3_proto;
-    packet.ts = packet_header.ts;
-
-    packet.ip_fragmented = packet_header.extended_hdr.parsed_pkt.ip_fragmented;
-    packet.ttl = packet_header.extended_hdr.parsed_pkt.ip_ttl;
-
-    // Copy flags from PF_RING header to our pseudo header
-    if (packet.protocol == IPPROTO_TCP) {
-        packet.flags = packet_header.extended_hdr.parsed_pkt.tcp.flags;
-    } else {
-        packet.flags = 0;
-    }
-
-    return true;
-} 
-
 void consume_pkt(u_char* buffer, int len, int thread_number) {
     // We should fill this structure for passing to FastNetMon
     simple_packet packet;
 
     packet.sample_ratio = netmap_sampling_ratio;
 
-    if (!parse_raw_packet_to_simple_packet(buffer, len, packet)) {
+    if (!parse_raw_packet_to_simple_packet(buffer, len, packet, netmap_read_packet_length_from_ip_header)) {
         total_unparsed_packets++;
 
         return;
diff --git a/src/pcap_reader.cpp b/src/pcap_reader.cpp
index a2e0137..7fb6b89 100644
--- a/src/pcap_reader.cpp
+++ b/src/pcap_reader.cpp
@@ -39,8 +39,7 @@
 #include "log4cpp/PatternLayout.hh"
 #include "log4cpp/Priority.hh"
 
-// We will use this code from Global Symbols table (originally it's defined in netmap collector.cpp)
-bool parse_raw_packet_to_simple_packet(u_char* buffer, int len, simple_packet& packet);
+#include "unified_parser.hpp"
 
 // Fake config
 std::map<std::string, std::string> configuration_map;
@@ -152,7 +151,7 @@ void pcap_parse_packet(char* buffer, uint32_t len, uint32_t snap_len) {
 
         simple_packet packet;
         // TODO: add support for caplen here!
-        if (parse_raw_packet_to_simple_packet((u_char*)buffer, len, packet)) {
+        if (parse_raw_packet_to_simple_packet((u_char*)buffer, len, packet, false)) {
             std::cout << "High level parser: " << print_simple_packet(packet) << std::endl;
         } else {
             printf("High level parser failed\n");
diff --git a/src/snabbswitch_plugin/snabbswitch_collector.cpp b/src/snabbswitch_plugin/snabbswitch_collector.cpp
index 207c5de..a36dd9b 100644
--- a/src/snabbswitch_plugin/snabbswitch_collector.cpp
+++ b/src/snabbswitch_plugin/snabbswitch_collector.cpp
@@ -33,6 +33,8 @@
 
 #include "snabbswitch_collector.h"
 
+#include "unified_parser.hpp"
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -71,13 +73,10 @@ struct firehose_rdesc {
     uint16_t vlan;
 } __attribute__((packed));
 
-// We will use this code from Global Symbols table (originally it's defined in netmap collector.cpp)
-bool parse_raw_packet_to_simple_packet(u_char* buffer, int len, simple_packet& packet);
-
 void firehose_packet(const char *pciaddr, char *data, int length) {
     simple_packet packet;
 
-    if (!parse_raw_packet_to_simple_packet((u_char*)data, length, packet)) {
+    if (!parse_raw_packet_to_simple_packet((u_char*)data, length, packet, false)) {
         total_unparsed_packets++;
 
         return;
diff --git a/src/unified_parser.cpp b/src/unified_parser.cpp
new file mode 100644
index 0000000..a171430
--- /dev/null
+++ b/src/unified_parser.cpp
@@ -0,0 +1,69 @@
+#include "unified_parser.hpp"
+
+#include "fastnetmon_packet_parser.h"
+
+bool parse_raw_packet_to_simple_packet(u_char* buffer, int len, simple_packet& packet, bool netmap_read_packet_length_from_ip_header) {
+	
+    struct pfring_pkthdr packet_header;
+
+    memset(&packet_header, 0, sizeof(packet_header));
+    packet_header.len = len;
+    packet_header.caplen = len;
+
+    // We do not calculate timestamps because timestamping is very CPU intensive operation:
+    // https://github.com/ntop/PF_RING/issues/9
+    u_int8_t timestamp = 0;
+    u_int8_t add_hash = 0;
+    fastnetmon_parse_pkt((u_char*)buffer, &packet_header, 4, timestamp, add_hash);
+
+    // char print_buffer[512];
+    // fastnetmon_print_parsed_pkt(print_buffer, 512, (u_char*)buffer, &packet_header);
+    // logger.info("%s", print_buffer);
+
+    if (packet_header.extended_hdr.parsed_pkt.ip_version != 4 && packet_header.extended_hdr.parsed_pkt.ip_version != 6) {
+        return false;
+    }
+
+    // We need this for deep packet inspection
+    packet.packet_payload_length = len;
+    packet.packet_payload_pointer = (void*)buffer;
+
+    packet.ip_protocol_version = packet_header.extended_hdr.parsed_pkt.ip_version;
+
+    if (packet.ip_protocol_version == 4) {
+        // IPv4
+
+        /* PF_RING stores data in host byte order but we use network byte order */
+        packet.src_ip = htonl(packet_header.extended_hdr.parsed_pkt.ip_src.v4);
+        packet.dst_ip = htonl(packet_header.extended_hdr.parsed_pkt.ip_dst.v4);
+    } else {
+        // IPv6
+       memcpy(packet.src_ipv6.s6_addr, packet_header.extended_hdr.parsed_pkt.ip_src.v6.s6_addr, 16);
+        memcpy(packet.dst_ipv6.s6_addr, packet_header.extended_hdr.parsed_pkt.ip_dst.v6.s6_addr, 16);
+    }
+
+    packet.source_port = packet_header.extended_hdr.parsed_pkt.l4_src_port;
+    packet.destination_port = packet_header.extended_hdr.parsed_pkt.l4_dst_port;
+
+    if (netmap_read_packet_length_from_ip_header) {
+        packet.length = packet_header.extended_hdr.parsed_pkt.ip_total_size;
+    } else {
+        packet.length = packet_header.len;
+    }
+
+    packet.protocol = packet_header.extended_hdr.parsed_pkt.l3_proto;
+    packet.ts = packet_header.ts;
+
+    packet.ip_fragmented = packet_header.extended_hdr.parsed_pkt.ip_fragmented;
+    packet.ttl = packet_header.extended_hdr.parsed_pkt.ip_ttl;
+
+    // Copy flags from PF_RING header to our pseudo header
+    if (packet.protocol == IPPROTO_TCP) {
+        packet.flags = packet_header.extended_hdr.parsed_pkt.tcp.flags;
+    } else {
+        packet.flags = 0;
+    }
+
+    return true;
+}
+
diff --git a/src/unified_parser.hpp b/src/unified_parser.hpp
new file mode 100644
index 0000000..4cadc4a
--- /dev/null
+++ b/src/unified_parser.hpp
@@ -0,0 +1,7 @@
+#pragma once
+
+#include <stdint.h>
+#include <sys/types.h>
+#include "fastnetmon_types.h"
+
+bool parse_raw_packet_to_simple_packet(u_char* buffer, int len, simple_packet& packet, bool netmap_read_packet_length_from_ip_header);
-- 
2.11.0

